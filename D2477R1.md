---
title: "Allow programmer to control and detect coroutine elision by static constexpr bool should_elide() and coroutine_handle::elided()"
document: D2477R1
date: 2021-10-14
audience: Evolution Working Group, Library Evolution Working Group
author:
  - name: Chuanqi Xu
    email: <chuanqi.xcq@alibaba-inc.com>
toc: true
toc-depth: 4
---

\pagebreak

# Abstract

It is a well-known problem that coroutine needs dynamic allocation to work. Although there is an optimization in the compiler, programmers couldn't control coroutine elision in a well-defined way. And there is not a good method that a programmer to use to detect whether the elision happened or not. So I proposed two methods. One for controlling the coroutine elision. And one for detecting it. Both of them wouldn't break any existing codes.

# Change Log

- Adding more examples. Many thanks for Lewis Baker offering these examples!
- Correcting that `coroutine_handle<>::elided` and `coroutine_handle<PromiseType>::elided()` should be a  runtime constant instead of a compile constant.
- Discussing how should we support `coroutine_handle<>::elided`.
- Discussing the semantics of the storage lifetime of  coroutine state.
- Raising the problem that indirect calls couldn't be elided.

# Background and Motivation

A coroutine needs space to store information (coroutine status) when it suspends. Generally, a coroutine would use `promise_type::operator new` (if existing) or `::operator new` to allocate coroutine status. However, it is expensive to allocate memory dynamically. Even we could use user-provided allocators, it is not easy (or very hard) to implement a safe and effective allocator. And dynamic allocation wouldn't be cheap than static allocation after all. 

To mitigate the expenses, Richard Smith and Gor Nishanov designed  [HALO](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0981r0.html) (which is called `coroutine elision` nowadays) to allocate coroutine on the stack when the compiler finds it is safe to do so. And there is a corresponding optimization called `CoroElide` in Clang/LLVM. But there is no word in the C++ specification about `coroutine elision`. It only says:

```
[dcl.fct.def.coroutine]p9
An implementation **may** need to allocate additional storage for a coroutine.
```

So it leaves the space for the compiler to do optimization. But it doesn't make any promise for programmers. So programmers couldn't find a well-defined method to control coroutine elision nor detect whether the coroutine elision happened. And `coroutine elision` doesn't like other compiler optimization since programmers could feel strongly about the dynamic allocation. So I feel it is necessary to support it.

Except for the general need to avoid dynamic allocation to speed up. I heard from Niall Douglas that it is needed to disable `coroutine elision` in an embedded system. In the resource-limited system, we could use `promise_type::operator new` to allocate space from a big static-allocated bytes array. And the feature to disable `coroutine elision` is not present in the standard too.

# Terminology

This section aims at explaining the terminologies in this proposal to avoid misunderstanding. This aim is not to discuss the words used in the specification formally. That should be discussed in the wording stage.

## HALO and Coroutine elision

The two terminologies refer to the same thing in this proposal. I found that people on the language side  prefer to use the term `HALO`. And the people on the compiler side prefer to use the term `Corotuine elision`. I like the term `Coroutine elision` more personally. We could discuss what's the preferred name later.

## constexpr time and compile time

Generally, these two terms refer to the same thing. But it's not the case for coroutine. For example, the layout of coroutine status is built at compile time. But the programmer couldn't see it. Informally, if a value is a constexpr-time constant, it could participate in the template/if-constexpr evaluation. And if a value is a compile-time constant, it needn't be evaluated at runtime. So simply, a constexpr-time constant is a compile-time constant. But a compile-time constant may not be a constexpr-time constant.

## Coroutine status and Corotuine frame

Coroutine status is an abstract concept used in the language standard to refer to all the information the coroutine should keep. And the coroutine frame refers to the data structure generated by the compiler to keep the information needed. We could think coroutine frame is a derived class of coroutine status : ).

## Ramp function

The compiler would split a coroutine function into several parts: ramp function, resume function and destroy function. Both the resume function and destroy function contain a compiler-generated state machine to make the coroutine work correctly. And the ramp function is the initial function that would initialize the coroutine frame.

# Design

The design consists of 2 parts. One for controlling the elision. One for detecting the elision. Both of them should be easy to understand.

## should_elide

If the compiler could find the name `should_elide` in the scope of promise_type, then if the result of `promise_type::should_elide()` evaluates to true at constexpr time, all the coroutine instances generated from the coroutine function are guaranteed to be elided.  Or if the result of `promise_type::should_elide()` evaluates to false at constexpr time, all the coroutine instances generated from the coroutine function are guaranteed to not be elided. Otherwise, if the compiler couldn't find `should_elide` in the scope of promise_type or the result of `promise_type::should_elide` couldn't be evaluated at constexpr time, the compiler is free to elide every single coroutine instance generated from the coroutine function.

### Semantics of the storage lifetime of  coroutine state

Simply, the semantics of the storage lifetime of a coroutine state is just like a corresponding local variable in the place of the callsite. In another word, the lifetime of the coroutine state would end at the end of the enclosing block. For example:

```C++
AlwaysElideTask an_elided_coroutine() { ... }

NormalTask example1(int count) {
  int sum = 0;
  for (int i = 0; i < count; ++i)
    sum += co_await an_elided_coroutine();

  co_return sum;
}
```

The coroutine created by `an_elided_coroutine()` would be elided. And it would be similar to the pseudocode:

```c++
AlwaysElideTask an_elided_coroutine() { ... }

NormalTask example(int count) {
  int sum = 0;
  for (int i = 0; i < count; ++i) {
    coroutine_status_ty coroutine_status;  // for an_elided_coroutine
    initializing coroutine_status...      
    any other works in an_elided_coroutine // This is possible if the intial_suspend 
                                           // of AlwaysElideTask is not suspend_alwyas.
    AlwaysElideTask Task = coroutine_status.promise.get_return_object();
    sum += co_await Task;
  }

  co_return sum;
}
```

So although the compiler couldn't know the value of `count` at constant time. It could still be able to calculate the stack size and the coroutine frame size that the function  `example` needed.

In the above explanation, we could find the following code is problematic.

```C++
Task<int> example2(int task_count) {
  std::vector<ElidedTask<int>> tasks;
  for (int i = 0; i < task_count; i++)
    tasks.empalce_back(coro_task());
	
  // the semantics of whenAll is that it would
  // complete after all the tasks completed.
  co_return co_await whenAll(std::move(tasks));
}
```

In the above example, the lifetime of all the coroutine generated from `coro_task` call would end after the for-loop ends. So when `whenAll` tries to access the coroutine refered by task in `tasks`, the behavior is undefined. Following is an pseudocode example which is easier to understand:

```C++
Task<int> example2(int task_count) {
  std::vector<coroutine_status_ty *> tasks;
  for (int i = 0; i < task_count; i++) {
    coroutine_status_ty coroutine_status;
    tasks.empalce_back(&coroutine_status);
  }
  
  // Now all the pointer in tasks are dangling
  // pointer!
  co_return co_await whenAll(std::move(tasks));
}
```

This situation couldn't be handled by this proposal. I think this kind of problem couldn't be solved in the current language framework since the compiler needs to ensure both the stack frame size and coroutine frame size (if any) at compile time. But the compiler couldn't infer the value  of `task_count` at compile time obviously.

Besides this situation, coroutine elision is workable under the use of goto, default function arguments, the initializer of an if-block, and the initializer of a class data-member. See the link in the Example section for details.

## elided

Add a non-static member bool function `elided` to `std::coroutine_handle<>` and `std::coroutine_handle<PromiseType>` .

```c++
namespace std {
  template<>
  struct coroutine_handle<void>
  { 
    // ...
    // [coroutine.handle.observers], observers
    constexpr explicit operator bool() const noexcept;
    bool done() const;
+   bool elided() const noexcept;
    // ...
  };

  template<class Promise>
  struct coroutine_handle
  {
    // ...
    // [coroutine.handle.observers], observers
    constexpr explicit operator bool() const noexcept;
    bool done() const;
+		bool elided() const noexcept;
		// ...
  };
}
```

And the semantic is clear. If the corresponding coroutine is elided, then `elided` would return true. And if the corresponding coroutine is not elided, then `elided` would return false.

Here are two reasons I want to introduce `elided`:

- For the language side, if we introduce the concept of coroutine elision in the language. It is odd that the user couldn't observe it.
- For the engineering side, as a new feature, the developer should write tests if they want to introduce this feature into their code bases. But they couldn't make it until `elided` is provided.

But introducing `elided` would introduce overhead. Since it would require the coroutine status to store extra information.

And here is 3 direction:

- Support both `coroutine_handle<>::elided()` and `coroutine_handle<PromiseType>::elided()`.
- Support `coroutine_handle<PromiseType>::elided()` only.
- Giving up to support `elided()`. 

### Support both

If we want to support both  `coroutine_handle<>::elided()` and `coroutine_handle<PromiseType>::elided()`, we must refactor the ABI for coroutine into the following form:

```C++
struct CoroutineFrame {
  void (*resume_func)(CoroutineFrame*);
  void (*destroy_func)(CoroutineFrame*);
  bool Elided;
  promise_type;
  // any other information needed
};
```

[Note: The current coroutine ABI is:

```C++
struct CoroutineFrame {
  void (*resume_func)(CoroutineFrame*);
  void (*destroy_func)(CoroutineFrame*);
  promise_type;
  // any other information needed
};
```

]

There are several drawbacks:

- It breaks the ABI.
- It would enlarge the coroutine frame. Due to the alignment requirement, it may introduce more space than 1 bit for every coroutine frame.
- It would introduce a store instruction for every coroutine.

For the ABI problem, I am not sure if it matters so much. There are some reasons:

- Coroutine is a new feature so the historical dependent problem may not be so large.
- Now, the different compilers would generate different ABI. The type for the resume_func, destroy_func, and the index for the state machine are not the same in different compilers.
- For the same compiler, the different versions of the compilers may generate different coroutine frames although their headers are the same. The remainder of the frame may be different.
- The coroutine ABI is not standardized as far as I know.

And for the second and the third drawbacks, they are the price we must pay to enable this feature.

And the implementation demo implements this strategy.

### Suppot coroutine_handle\<PromiseType\>::elided() only

If we decided to not support `coroutine_handle<>::elided()`, we could move the `Elided` bit in the back of `promise_type`:

```C++
struct CoroutineFrame {
  void (*resume_func)(CoroutineFrame*),
  void (*destroy_func)(CoroutineFrame*),
  promise_type,
  bool Elided,
  // any other information needed
};
```

So that we could avoid the ABI problems. But I feel odd for giving up to support `coroutine_handle<>::elided`. Since `coroutine_handle<>` is a generic abstract for coroutine and `elided` should be a generic feature for all the coroutine.

### Giving up to support elided

This is simple. We wouldn't need to pay anything in implementation and language wording.

### Summarize

I prefer to support both and pay for the price for more space needed and the extra store instruction. But I am not so sure since the use cases for `elided` I got now are in the test only. And for the codes which are actually running in production, I couldn't imagine the use cases for `elided`. So in another word, the people who use coroutine in production would pay for the price that they don't use. This violates the principle of C++ that "Pay for what you use". But as I said, it is really odd that people could control coroutine elision without observing it.

So I am not sure about this. Any opinion is welcome.

# Examples

A set of examples could be found at [Examples](https://github.com/ChuanqiXu9/llvm-project/tree/CoroShouldElide/ShouldElide). Example-1~6 mimic the use of loop, select operator, goto statement, function default argument, the initializer of an if-block, and the initializer of a class data-member. All of them are simple and easy to understand. Here talks about the basic usage for `should_elide` only.

## Always Enable/Disable coroutine elision

We could enable/disable coroutine elision for a kind of coroutine like:

```C++
struct TaskPromiseAlwaysElide : public TaskPromiseBase {
    static constexpr bool should_elide() {
        return true;
    }
};

struct TaskPromiseNeverElide : public TaskPromiseBase {
    static constexpr bool should_elide() {
        return false;
    }
};
```

Then for the coroutine like:

```c++
template<class PromiseType>
class Task : public TaskBase{
public:
    using promise_type = PromiseType;
    using HandleType = std::experimental::coroutine_handle<promise_type>;
    // ...
}; // end of Task
using AlwaysElideTask = Task<TaskPromiseAlwaysElide>;
using NeverElideTask = Task<TaskPromiseNeverElide>;

AlwaysElideTask always_elide_task () {
    // ... contain coroutine keywords
}
NeverElideTask never_elide_task () {
    // ... contain coroutine keywords
}
```

Then every coroutine instance generated from `always_elide_task()` would be elided. And every coroutine instance generated from `never_elide_task` wouldn't be elided.

## No guarantee to coroutine elision

If the compiler couldn't infer the result of `promise_type::should_elide` at compile time, then the compiler is free to do elision or not. And the behavior would be the same with `should_elide` is not exist in `promise_type`.

```c++
bool undertermism;
struct TaskPromiseMeaningless : public TaskPromiseBase {
    static constexpr bool should_elide() {
        return undertermism;
    }
};
```

Then `TaskPromiseMeaningless` would be the same as `TaskPromiseBase` for every case.

## Controlling the elision at callsite

It is possible that we could control coroutine elision for specific call. Here is my demo, 

```c++
using NormalTask = Task<TaskPromiseBase>;
using AlwaysElideTask = Task<TaskPromiseAlwaysElide>;
using NeverElideTask = Task<TaskPromiseNeverElide>;

struct ShouldElideTagT;
struct NoElideTagT;
struct MayElideTagT;

template<typename T>
concept ElideTag = (std::same_as<T, ShouldElideTagT> ||
                    std::same_as<T, NoElideTagT> ||
                    std::same_as<T, MayElideTagT>);

bool undetermism;
template <ElideTag Tag>
struct TaskPromiseAlternative : public TaskPromiseBase {
    static constexpr bool should_elide() {
        if constexpr (std::is_same_v<Tag, ShouldElideTagT>)
            return true;
        else if constexpr (std::is_same_v<Tag, NoElideTagT>)
            return false;
        else
            return undetermism;
    }
};

template <ElideTag Tag = MayElideTagT>
using AlternativeTask = Task<TaskPromiseAlternative<Tag>>;

template <ElideTag Tag>
AlternativeTask<Tag> alternative_task () { /* ... */ } // This is a coroutine

int foo() {
  auto t1 = alternative_task<ShouldElideTagT>();
  // Task::elided would call coroutine_handle::elided
  assert (t1.elided());
  auto t2 = alternative_task<NoElideTagT>();
  assert (!t1.elided());
  // The default case, which would be general for most cases
  alternative_task(); 
} 
```

From the example in `foo`, we could find that we get the ability to control elision at callsite finally! Although it looks tedious to add `template <ElideTag Tag>` alone the way. But I believe the cases that we need to control wouldn't be too much. We only need to control some of the coroutines in a project.

# Issue

## Elision cross translation unit

A big issue I see now is that we couldn't elide a coroutine into a function in another translation unit. Let's see the example:

```c++
// CoroType.h
class PromiseType {
public:
  static constexpr bool should_elide() {
     return true;
  }
  // ...
};
class AlwaysElideTask {
  using promise_type = PromiseType;
  // ...
};
AlwaysElideTask may_be_a_coroutine();      // We couldn't see if this is a coroutine
                                           // from the signature.
// A.cpp
AlwaysElideTask may_be_a_coroutine() {     // It is a coroutine indeed.
  co_await std::suspend_always{};
  // ... Other works needed.
}
// B.cpp
AlwaysElideTask CoroA() {
  co_return co_await may_be_a_coroutine(); // Is it a coroutine?
}

```

The example above shows the issue directly. We couldn't elide a coroutine defined in another translation unit since we couldn't know if it is coroutine even! 

Could we solve this problem by adding a special function attribute to mark a function as a coroutine? No, we can't. Since at least we need to know how many bits we need to allocate the coroutine status if we want to do elide. And the compiler couldn't infer that if it couldn't see the body of the coroutine. The key point here is that the compiler would compile translation units one by one and the compiler couldn't see the intents from other translation units.

From the perspective of a compiler, this issue is potentially solvable by enabling LTO (Link Time Optimization). In LTO, the compiler could see every translation unit. But since we are talking about the language standard. I feel like that is not possible that we could add the concept LTO in the standard nor we could change the compilation model.

So this problem is unsolvable if we didn't change the compilation model. So the only solution I could imagine is that we constrain the semantics of `should_elide`  by specifying that we couldn't elide a coroutine in another translation unit explicitly in the standard.

## Indirect Call

Another issue I see is the indirect call to coroutine. Although I didn't see this kind of usages in actual code. Here is an example:

```
std::function<AlwaysElideTask()> coro_func;
co_await coro_func();
```

Although we could see from the signature the function that `coro_func` refers to should elide all the way. But the compiler couldn't elide it actually since it can't know the coroutine `coro_func` refers to usually. The reason for this issue is similar to the issue above. And the compiler couldn't do too much even if we could use any hack  possible.

# Implementation

An implementation could be found here: [CoroShouldElide](https://github.com/ChuanqiXu9/llvm-project/tree/CoroShouldElide).

## Current Implementation issue

An issue in the current implementation is that: it could work only if we turned optimization on. In other words, if we define this in the specification, it should work correctly under O0.

The reason is the internal pass ordering problem in the compiler. I definitely believe it could be solved if we get in consensus on this proposal.

## Implementation in GCC

Mathias Stearn points out that there is no coroutine elision optimization in GCC now. So it would be harder to implement this proposal in GCC since it would require GCC to implement coroutine elision first.

# Q&A

This section includes the questions had been asked and the corresponding answer.

## How does the compiler guarantee coroutine elision if should_elide evaluates to true at constexpr time

Here talks about the case of clang only. Since the question was raised because clang handles coroutine in two parts, the frontend part and the middle end part. But I think this wouldn't be a problem for GCC since GCC handles coroutine in the frontend.

Simply, the frontend would pass specified information to the middle end after parsing source codes. So when the frontend sees the value of `promise_type::should_elide` evaluates to true or false, the frontend would pass a special marker to the middle end to inform that the coroutine should be elided or not.

Due to that coroutine elision depends on inlining now. So in the case, the middle end sees an `always-elide` marker, it would mark the ramp function as `always_inline` to ensure it could be inlined as expected.

## Is elided() a constexpr function?

No, although it looks like a constexpr function. Even its result isn't a compile time constant. This doesn't make much sense. Since we could know that the elision is done at compile time. So it is natural that whether or not a coroutine is elided at runtime. But the point here is that we couldn't associate any coroutine_hadle with a coroutine at compile time. For example:

```c++
__attribute__((noinline))
bool IsElided(coroutine_handle<> handle) {
  return handle.elided();
}
```

The compiler couldn't connect the handle with a coroutine clearly. So it must  read information  somewhere.
